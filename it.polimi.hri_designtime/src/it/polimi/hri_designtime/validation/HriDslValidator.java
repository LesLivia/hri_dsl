/*
 * generated by Xtext 2.28.0
 */
package it.polimi.hri_designtime.validation;


import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.HashMap;
import java.util.HashSet;
import org.eclipse.xtext.validation.Check;

import it.polimi.hri_designtime.hriDsl.Assignment;
import it.polimi.hri_designtime.hriDsl.HriDslPackage;
import it.polimi.hri_designtime.hriDsl.Floor;
import it.polimi.hri_designtime.hriDsl.Human;
import it.polimi.hri_designtime.hriDsl.Humans;
import it.polimi.hri_designtime.hriDsl.Mission;
import it.polimi.hri_designtime.hriDsl.Model;
import it.polimi.hri_designtime.hriDsl.Point;
import it.polimi.hri_designtime.hriDsl.Robot;
import it.polimi.hri_designtime.hriDsl.Robots;
import it.polimi.hri_designtime.hriDsl.Scenario;
import it.polimi.hri_designtime.hriDsl.Surface;
import it.polimi.hri_designtime.generator.Operations;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class HriDslValidator extends AbstractHriDslValidator {	
	
	@Check
	public void checkUniqueFloorName(Model model) {
		HashSet<String> floorSet = new HashSet<String>();
		
		if(model.getScenarios() != null) {
			for(Scenario s: model.getScenarios()) {
				if(s.getFloor() != null && s.getFloor().getFloor_name() != null && !floorSet.add(s.getFloor().getFloor_name())){
					error("Error: " + "the floor name \"" + s.getFloor().getFloor_name() + "\" has already been used.\n" + "The floor name must be unique.", s.getFloor(), HriDslPackage.Literals.FLOOR__FLOOR_NAME);
				}
			}
		}
	}
	
	@Check
	public void checkUniqueSurfaceName(Floor floor) {
		HashSet<String> surfaceSet = new HashSet<String>();
		
		if(floor.getSurfaces() != null) {
			for(Surface s: floor.getSurfaces()) {
				if(s.getName() != null && !surfaceSet.add(s.getName())){
					error("Error: " + "the rectangular_surface name \"" + s.getName() + "\" has already been used for this floor.\n" + "The rectangular_surface name must be unique for the same floor.", s, HriDslPackage.Literals.SURFACE__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkVerticesValidity(Surface surface) {
		if(surface.getVertices() != null && surface.getVertices().getVertex_A() != null && surface.getVertices().getVertex_C() != null) {
			float Vertex_A_coordinate_x = surface.getVertices().getVertex_A().getX();
			float Vertex_A_coordinate_y = surface.getVertices().getVertex_A().getY();
			float Vertex_C_coordinate_x = surface.getVertices().getVertex_C().getX();
			float Vertex_C_coordinate_y = surface.getVertices().getVertex_C().getY();
			
				if(Vertex_A_coordinate_x == Vertex_C_coordinate_x) {
					error("Error: " + "the coordinates of the vertices A and C must be different.\n" + "To represent a rectangular_surface the vertices A and C cannot be overlapped or aligned.\n" + "rectangular_surface representation:\nA ---- B\n   |     |\nD ---- C", surface.getVertices().getVertex_C(), HriDslPackage.Literals.COORDINATES__X);
				}
				if(Vertex_A_coordinate_y == Vertex_C_coordinate_y) {
					error("Error: " + "the coordinates of the vertices A and C must be different.\n" + "To represent a rectangular_surface the vertices A and C cannot be overlapped or aligned.\n" + "rectangular_surface representation:\nA ---- B\n   |     |\nD ---- C", surface.getVertices().getVertex_C(), HriDslPackage.Literals.COORDINATES__Y);
				}
			
		}
	}
	
	@Check
	public void checkOverlappingRectangles(Floor floor) {
		HashSet<Integer> indexSet = new HashSet<Integer>();
		
		if(floor.getSurfaces() != null){
			for(int i=0; i < floor.getSurfaces().size()-1; i++){
				for(int j=i+1; j < floor.getSurfaces().size(); j++){
					if(floor.getSurfaces().get(i).getVertices() != null && floor.getSurfaces().get(j).getVertices() != null && floor.getSurfaces().get(i).getVertices().getVertex_A() != null && floor.getSurfaces().get(j).getVertices().getVertex_A() != null && floor.getSurfaces().get(i).getVertices().getVertex_C() != null && floor.getSurfaces().get(j).getVertices().getVertex_C() != null){
						if(floor.getSurfaces().get(i).getVertices().getVertex_A().getX() == floor.getSurfaces().get(j).getVertices().getVertex_A().getX() && floor.getSurfaces().get(i).getVertices().getVertex_A().getY() == floor.getSurfaces().get(j).getVertices().getVertex_A().getY() && floor.getSurfaces().get(i).getVertices().getVertex_C().getX() == floor.getSurfaces().get(j).getVertices().getVertex_C().getX() && floor.getSurfaces().get(i).getVertices().getVertex_C().getY() == floor.getSurfaces().get(j).getVertices().getVertex_C().getY()) {
							if(indexSet.add(j)) {
								error("Error: " + "the rectangular_surface \"" + floor.getSurfaces().get(j).getName() + "\" and the rectangular_surface \"" + floor.getSurfaces().get(i).getName() + "\" are overlapped.\n" + "There cannot be two rectangular_surface with the same vertices.", floor.getSurfaces().get(j), HriDslPackage.Literals.SURFACE__NAME);
							}
						}
					}
				}
			}
		}
	}
	
	@Check
	public void checkUniquePointName(Floor floor) {
		HashSet<String> pointSet = new HashSet<String>();
		
		if(floor.getPoints() != null) {
			for(Point p: floor.getPoints()) {
				if(p.getName() != null && !pointSet.add(p.getName())){
					error("Error: " + "the point_of_interest name \"" + p.getName() + "\" has already been used for this floor.\n" + "The point_of_interest name must be unique for the same floor.", p, HriDslPackage.Literals.POINT__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkPointValidity(Floor floor) {
		Operations op = new Operations();
		
		if(floor.getPoints() != null && floor.getSurfaces() != null){
			for(Point p: floor.getPoints()) {
				if(p.getCoordinates() != null && p.getName() != null){
					boolean valid = false;
					for(Surface s: floor.getSurfaces()){
						if(s.getVertices() != null && s.getVertices().getVertex_A() != null && s.getVertices().getVertex_C() != null){
							Rectangle2D.Float r = op.createRectangle(s);
							if(r != null) {
								if(r.contains(p.getCoordinates().getX(), p.getCoordinates().getY())){
									valid = true;
									break;
								}
							}
						}
					}
					if(!valid){
						error("Error: " + "the point_of_interest \"" + p.getName() + "\" is not valid.\n" + "The coordinates of the point_of_interest must be into a rectangular_surface.", p, HriDslPackage.Literals.POINT__NAME);
					}
				}
			}
		}
	}
	
	@Check
	public void checkUniqueRobotName(Robots robots) {
		HashSet<String> robotSet = new HashSet<String>();
		
		if(robots.getRobots() != null){
			for(Robot r: robots.getRobots()) {
				if(r.getName() != null && !robotSet.add(r.getName())){
					error("Error: " + "the robot name \"" + r.getName() + "\" has already been used for this floor.\n" + "The robot name must be unique for the same floor.", r, HriDslPackage.Literals.ROBOT__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkUniqueRobotHumanPosition(Scenario scenario) {
		HashMap<Point2D.Float, String> positionMap = new HashMap<Point2D.Float, String>();
		String name = new String();
		
		if(scenario.getRobots() != null && scenario.getRobots().getRobots() != null){
			for(Robot r: scenario.getRobots().getRobots()) {
				if(r.getCoordinates() != null && r.getName() != null){
					name = positionMap.putIfAbsent(new Point2D.Float(r.getCoordinates().getX(), r.getCoordinates().getY()), r.getName());
					if(name != null) {
						error("Error: " + "the robot coordinates \"(" + r.getCoordinates().getX() + ";" + r.getCoordinates().getY() + ")\" has already been used for " + name + ".\n" + "Change starting position.", r, HriDslPackage.Literals.ROBOT__NAME);
					}
				}
			}
		}
		if(scenario.getHumans() != null && scenario.getHumans().getHumans() != null){
			for(Human h: scenario.getHumans().getHumans()) {
				if(h.getCoordinates() != null && h.getName() != null){
					name = positionMap.putIfAbsent(new Point2D.Float(h.getCoordinates().getX(), h.getCoordinates().getY()), h.getName());
					if(name != null) {
						error("Error: " + "the human coordinates \"(" + h.getCoordinates().getX() + ";" + h.getCoordinates().getY() + ")\" has already been used for " + name + ".\n" + "Change starting position.", h, HriDslPackage.Literals.HUMAN__NAME);
					}
				}
			}
		}
	}
	
	public static final String PERCENTAGE = "percentage";
	@Check
	public void checkChargePercentage(Robot robot) {
		if(robot.getCharge_percentage() > 100) {
			error("Error: " + "the robot charge_percentage cannot be more than 100", robot, HriDslPackage.Literals.ROBOT__CHARGE_PERCENTAGE, HriDslValidator.PERCENTAGE, String.valueOf(robot.getCharge_percentage()));
		}
	}
	
	@Check
	public void checkRobotPositionValidity(Scenario scenario) {
		Operations op = new Operations();
		
		if(scenario.getRobots() != null && scenario.getRobots().getRobots() != null && scenario.getFloor() != null && scenario.getFloor().getSurfaces() != null){
			for(Robot robot: scenario.getRobots().getRobots()) {
				if(robot.getCoordinates() != null && robot.getName() != null){
					boolean valid = false;
					for(Surface s: scenario.getFloor().getSurfaces()) {
						if(s.getVertices() != null && s.getVertices().getVertex_A() != null && s.getVertices().getVertex_C() != null) {
							Rectangle2D.Float rectangle = op.createRectangle(s);
							if(rectangle != null) {
								if(rectangle.contains(robot.getCoordinates().getX(), robot.getCoordinates().getY())) {
									valid = true;
									break;
								}
							}
						}
					}
					if(!valid) {
						error("Error: " + "the coordinates of the robot \"" + robot.getName() + "\" are not valid.\n" + "The coordinates of the robot must be into a rectangular_surface.", robot, HriDslPackage.Literals.ROBOT__NAME);
					}
				}
			}
		}
	}
	
	@Check
	public void checkUniqueHumanName(Humans humans) {
		HashSet<String> humansSet = new HashSet<String>();
		
		if(humans.getHumans() != null){
			for(Human h: humans.getHumans()){
				if(h.getName() != null && !humansSet.add(h.getName())){
					error("Error: " + "the human name \"" + h.getName() + "\" has already been used for this floor.\n" + "The human name must be unique for the same floor.", h, HriDslPackage.Literals.HUMAN__NAME);
				}
			}
		}
	}
	
	
	
	@Check
	public void checkHumanPositionValidity(Scenario scenario) {
		Operations op = new Operations();
		
		if(scenario.getHumans() != null && scenario.getHumans().getHumans() != null && scenario.getFloor() != null && scenario.getFloor().getSurfaces() != null){
			for(Human human: scenario.getHumans().getHumans()) {
				if(human.getCoordinates() != null && human.getName() != null){
					boolean valid = false;
					for(Surface s: scenario.getFloor().getSurfaces()) {
						if(s.getVertices() != null && s.getVertices().getVertex_A() != null && s.getVertices().getVertex_C() != null){
							Rectangle2D.Float rectangle = op.createRectangle(s);
							if(rectangle != null) {
								if(rectangle.contains(human.getCoordinates().getX(), human.getCoordinates().getY())) {
									valid = true;
									break;
								}
							}
						}
					}
					if(!valid) {
						error("Error: " + "the coordinates of the human \"" + human.getName() + "\" are not valid.\n" + "The coordinates of the human must be into a rectangular_surface.", human, HriDslPackage.Literals.HUMAN__NAME);
					}
				}
			}
		}
	}
	
	@Check
	public void checkUniqueMissionName(Scenario scenario) {
		HashSet<String> missionsSet = new HashSet<String>();
		
		if(scenario.getMissions() != null) {
			for(Mission m: scenario.getMissions()) {
				if(m.getName() != null && !missionsSet.add(m.getName())){
					error("Error: " + "the mission name \"" + m.getName() + "\" has already been used for this floor.\n" + "The mission name must be unique for the same floor.", m, HriDslPackage.Literals.MISSION__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkAllHumansAreServed(Scenario scenario) {
		
		if(scenario.getMissions() != null && scenario.getHumans() != null && scenario.getHumans().getHumans() != null){
			for(Mission m: scenario.getMissions()){
				if(m.getName() != null && m.getAssignments() != null){
					for(Human h: scenario.getHumans().getHumans()){
						if(h.getName() != null){
							boolean valid = false;
							for(Assignment a: m.getAssignments()) {
								if(a.getClient() != null && a.getClient().equals(h.getName())) {
									valid = true;
									break;
								}
							}
							if(!valid){
								error("Error: " + "the mission \"" + m.getName() + "\" does not contain an assignment for the human \"" + h.getName() + "\".\n" + "The mission must contain an assignment for each human on the floor.", m, HriDslPackage.Literals.MISSION__NAME);
							}
						}
					}
				}
			}
		}
	}
	
	@Check
	public void checkExistingHuman(Scenario scenario) {
		
		if(scenario.getMissions() != null && scenario.getHumans() != null && scenario.getHumans().getHumans() != null){
			for(Mission m: scenario.getMissions()){
				if(m.getAssignments() != null){
					for(Assignment a: m.getAssignments()) {
						if(a.getClient() != null){
							boolean valid = false;
							for(Human h: scenario.getHumans().getHumans()){
								if(h.getName() != null && a.getClient().equals(h.getName())) {
									valid = true;
									break;
								}
							}
							if(!valid){
								error("Error: " + "the human \"" + a.getClient() + "\" does not exist.\n" + "Enter the human in the humans block.", a, HriDslPackage.Literals.ASSIGNMENT__CLIENT);
							}
						}
					}
				}
			}
		}
	}
	
	@Check
	public void checkDuplicates(Mission mission){
		HashSet<String> humanSet = new HashSet<String>();
		
		if(mission.getAssignments() != null){
			for(Assignment a: mission.getAssignments()){
				if(a.getClient() != null && !humanSet.add(a.getClient())) {
					error("Error: " + "the human \"" + a.getClient() + "\" is already present in this mission.\n", a, HriDslPackage.Literals.ASSIGNMENT__CLIENT);
				}
			}
		}
	}
	
	@Check
	public void checkExistingPoint(Scenario scenario) {
		
		if(scenario.getMissions() != null && scenario.getFloor() != null && scenario.getFloor().getPoints() != null){
			for(Mission m: scenario.getMissions()){
				if(m.getAssignments() != null){
					for(Assignment a: m.getAssignments()) {
						if(a.getTarget() != null){
							boolean valid = false;
							for(Point p: scenario.getFloor().getPoints()){
								if(p.getName() != null && a.getTarget().equals(p.getName())) {
									valid = true;
									break;
								}
							}
							if(!valid){
								error("Error: " + "the target \"" + a.getTarget() + "\" does not exist.\n" + "Enter the target in the point_of_interest section.", a, HriDslPackage.Literals.ASSIGNMENT__TARGET);
							}
						}
					}
				}
			}
		}
	}
	
	@Check
	public void checkPoint(Scenario scenario) {
		
		if(scenario.getFloor() != null && scenario.getFloor().getPoints() != null && scenario.getMissions() != null){
			for(Point p: scenario.getFloor().getPoints()){
				if(p.getName() != null){
					boolean valid = false;
					for(Mission m: scenario.getMissions()){
						if(m.getAssignments() != null){
							for(Assignment a: m.getAssignments()) {
								if(a.getTarget() != null && a.getTarget().equals(p.getName())) {
									valid = true;
									break;
								}
							}
						}
						if(valid){break;}
					}
					if(!valid){
						warning("Warning: " + "the point_of_interest \"" + p.getName() + "\" is not used.", p, HriDslPackage.Literals.POINT__NAME);
					}
				}
			}
		}
	}
	
	public static final String QUERY_DEFINITION = "query_definition";
	@Check
	public void checkQuery(Mission mission) {
		
		if(mission.getQueries() != null && mission.getQueries().getMission() != null) {
			if(mission.getName() != null && !mission.getName().equals(mission.getQueries().getMission())){
				error("Error: " + "the mission name \"" + mission.getQueries().getMission() + "\" should be \"" + mission.getName() + "\".", mission.getQueries(), HriDslPackage.Literals.QUERIES__MISSION, HriDslValidator.QUERY_DEFINITION, mission.getQueries().getMission(),mission.getName());
			}
		}
	}

}
