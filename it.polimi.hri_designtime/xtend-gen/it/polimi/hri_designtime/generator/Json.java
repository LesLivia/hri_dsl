/**
 * generated by Xtext 2.28.0
 */
package it.polimi.hri_designtime.generator;

import it.polimi.hri_designtime.hriDsl.Assignment;
import it.polimi.hri_designtime.hriDsl.Human;
import it.polimi.hri_designtime.hriDsl.Mission;
import it.polimi.hri_designtime.hriDsl.Parameter;
import it.polimi.hri_designtime.hriDsl.Point;
import it.polimi.hri_designtime.hriDsl.Query;
import it.polimi.hri_designtime.hriDsl.Robot;
import it.polimi.hri_designtime.hriDsl.Scenario;
import it.polimi.hri_designtime.hriDsl.Surface;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

@SuppressWarnings("all")
public class Json {
  private Operations op = new Operations();
  
  public CharSequence pQuery(final Query q) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{ \"type\": \"");
    CharSequence _switchResult = null;
    String _string = q.getQuery_type().toString();
    if (_string != null) {
      switch (_string) {
        case "simulation":
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("sim");
          _switchResult = _builder_1;
          break;
        case "probability_of_success":
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("pscs");
          _switchResult = _builder_2;
          break;
        case "expected_fatigue":
          StringConcatenation _builder_3 = new StringConcatenation();
          _builder_3.append("eftg");
          _switchResult = _builder_3;
          break;
        case "expected_charge":
          StringConcatenation _builder_4 = new StringConcatenation();
          _builder_4.append("echg");
          _switchResult = _builder_4;
          break;
        case "probability_of_failure":
          StringConcatenation _builder_5 = new StringConcatenation();
          _builder_5.append("pfail");
          _switchResult = _builder_5;
          break;
        default:
          _switchResult = null;
          break;
      }
    } else {
      _switchResult = null;
    }
    _builder.append(_switchResult);
    _builder.append("\", \"tau\": ");
    int _duration = q.getDuration();
    _builder.append(_duration);
    _builder.append(", \"n\": ");
    int _xifexpression = (int) 0;
    int _runs = q.getRuns();
    boolean _equals = (_runs == 0);
    if (_equals) {
      _xifexpression = (-1);
    } else {
      _xifexpression = q.getRuns();
    }
    _builder.append(_xifexpression);
    _builder.append(" }");
    return _builder;
  }
  
  public CharSequence pRobots(final int id, final Robot r, final Parameter parameter) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{ \"name\": \"");
    String _name = r.getName();
    _builder.append(_name);
    _builder.append("\", \"r_id\": ");
    _builder.append(id);
    _builder.append(", ");
    CharSequence _switchResult = null;
    String _string = r.getType().toString();
    if (_string != null) {
      switch (_string) {
        case "turtlebot3_burger":
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("\"v\": ");
          float _unitConversion = this.op.unitConversion(0.22f, parameter);
          _builder_1.append(_unitConversion);
          _builder_1.append(", \"a\": ");
          float _unitConversion_1 = this.op.unitConversion(0.22f, parameter);
          _builder_1.append(_unitConversion_1);
          _switchResult = _builder_1;
          break;
        case "turtlebot3_wafflepi":
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("\"v\": ");
          float _unitConversion_2 = this.op.unitConversion(0.26f, parameter);
          _builder_2.append(_unitConversion_2);
          _builder_2.append(", \"a\": ");
          float _unitConversion_3 = this.op.unitConversion(0.26f, parameter);
          _builder_2.append(_unitConversion_3);
          _switchResult = _builder_2;
          break;
        case "tiago":
          StringConcatenation _builder_3 = new StringConcatenation();
          _builder_3.append("\"v\": ");
          float _unitConversion_4 = this.op.unitConversion(1.0f, parameter);
          _builder_3.append(_unitConversion_4);
          _builder_3.append(", \"a\": ");
          float _unitConversion_5 = this.op.unitConversion(1.0f, parameter);
          _builder_3.append(_unitConversion_5);
          _switchResult = _builder_3;
          break;
        case "pepper":
          StringConcatenation _builder_4 = new StringConcatenation();
          _builder_4.append("\"v\": ");
          float _unitConversion_6 = this.op.unitConversion(0.83f, parameter);
          _builder_4.append(_unitConversion_6);
          _builder_4.append(", \"a\": ");
          float _unitConversion_7 = this.op.unitConversion(0.83f, parameter);
          _builder_4.append(_unitConversion_7);
          _switchResult = _builder_4;
          break;
        default:
          _switchResult = null;
          break;
      }
    } else {
      _switchResult = null;
    }
    _builder.append(_switchResult);
    _builder.append(", \"start\": [");
    float _x = r.getCoordinates().getX();
    _builder.append(_x);
    _builder.append(", ");
    float _y = r.getCoordinates().getY();
    _builder.append(_y);
    _builder.append("], \"chg\": ");
    int _charge_percentage = r.getCharge_percentage();
    _builder.append(_charge_percentage);
    _builder.append(" }");
    return _builder;
  }
  
  public CharSequence pAreas(final Surface s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{ \"p1\": [");
    float _x = s.getVertices().getVertex_A().getX();
    _builder.append(_x);
    _builder.append(", ");
    float _y = s.getVertices().getVertex_A().getY();
    _builder.append(_y);
    _builder.append("], \"p2\": [");
    float _x_1 = s.getVertices().getVertex_C().getX();
    _builder.append(_x_1);
    _builder.append(", ");
    float _y_1 = s.getVertices().getVertex_A().getY();
    _builder.append(_y_1);
    _builder.append("], \"p3\": [");
    float _x_2 = s.getVertices().getVertex_C().getX();
    _builder.append(_x_2);
    _builder.append(", ");
    float _y_2 = s.getVertices().getVertex_C().getY();
    _builder.append(_y_2);
    _builder.append("], \"p4\": [");
    float _x_3 = s.getVertices().getVertex_A().getX();
    _builder.append(_x_3);
    _builder.append(", ");
    float _y_3 = s.getVertices().getVertex_C().getY();
    _builder.append(_y_3);
    _builder.append("] }");
    return _builder;
  }
  
  public CharSequence pIntersect(final float x, final float y) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{ \"p\": [");
    _builder.append(x);
    _builder.append(", ");
    _builder.append(y);
    _builder.append("] }");
    return _builder;
  }
  
  public CharSequence pHumans(final int id, final Human h, final Assignment a, final Point p) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _equals = h.getName().equals(a.getClient());
      if (_equals) {
        {
          boolean _equals_1 = a.getTarget().equals(p.getName());
          if (_equals_1) {
            _builder.append("{ \"name\": \"");
            String _name = h.getName();
            _builder.append(_name);
            _builder.append("\", \"h_id\": ");
            _builder.append(id);
            _builder.append(", \"v\": ");
            float _speed = h.getSpeed();
            _builder.append(_speed);
            _builder.append(", \"ptrn\": \"");
            CharSequence _switchResult = null;
            String _string = a.getPattern().toString();
            if (_string != null) {
              switch (_string) {
                case "robot_leader":
                  StringConcatenation _builder_1 = new StringConcatenation();
                  _builder_1.append("FOLLOWER");
                  _switchResult = _builder_1;
                  break;
                case "robot_follower":
                  StringConcatenation _builder_2 = new StringConcatenation();
                  _builder_2.append("LEADER");
                  _switchResult = _builder_2;
                  break;
                case "robot_transporter":
                  StringConcatenation _builder_3 = new StringConcatenation();
                  _builder_3.append("RECIPIENT");
                  _switchResult = _builder_3;
                  break;
                case "robot_competitor":
                  StringConcatenation _builder_4 = new StringConcatenation();
                  _builder_4.append("COMPETITOR");
                  _switchResult = _builder_4;
                  break;
                case "robot_rescuer":
                  StringConcatenation _builder_5 = new StringConcatenation();
                  _builder_5.append("ASSISTANT");
                  _switchResult = _builder_5;
                  break;
                case "robot_client":
                  StringConcatenation _builder_6 = new StringConcatenation();
                  _builder_6.append("RESCUER");
                  _switchResult = _builder_6;
                  break;
                default:
                  _switchResult = null;
                  break;
              }
            } else {
              _switchResult = null;
            }
            _builder.append(_switchResult);
            _builder.append("\", \"p_f\": \"");
            CharSequence _switchResult_1 = null;
            String _string_1 = h.getFatigue_profile().toString();
            if (_string_1 != null) {
              switch (_string_1) {
                case "young_healthy":
                  StringConcatenation _builder_7 = new StringConcatenation();
                  _builder_7.append("y/h");
                  _switchResult_1 = _builder_7;
                  break;
                case "young_sick":
                  StringConcatenation _builder_8 = new StringConcatenation();
                  _builder_8.append("y/s");
                  _switchResult_1 = _builder_8;
                  break;
                case "elderly_healthy":
                  StringConcatenation _builder_9 = new StringConcatenation();
                  _builder_9.append("e/h");
                  _switchResult_1 = _builder_9;
                  break;
                case "elderly_sick":
                  StringConcatenation _builder_10 = new StringConcatenation();
                  _builder_10.append("e/s");
                  _switchResult_1 = _builder_10;
                  break;
                case "covid_patient":
                  StringConcatenation _builder_11 = new StringConcatenation();
                  _builder_11.append("c");
                  _switchResult_1 = _builder_11;
                  break;
                default:
                  _switchResult_1 = null;
                  break;
              }
            } else {
              _switchResult_1 = null;
            }
            _builder.append(_switchResult_1);
            _builder.append("\", \"p_fw\": \"");
            CharSequence _switchResult_2 = null;
            String _string_2 = h.getFree_will_profile().toString();
            if (_string_2 != null) {
              switch (_string_2) {
                case "normal":
                  StringConcatenation _builder_12 = new StringConcatenation();
                  _builder_12.append("n");
                  _switchResult_2 = _builder_12;
                  break;
                case "high":
                  StringConcatenation _builder_13 = new StringConcatenation();
                  _builder_13.append("h");
                  _switchResult_2 = _builder_13;
                  break;
                case "low":
                  StringConcatenation _builder_14 = new StringConcatenation();
                  _builder_14.append("l");
                  _switchResult_2 = _builder_14;
                  break;
                case "disabled":
                  StringConcatenation _builder_15 = new StringConcatenation();
                  _builder_15.append("d");
                  _switchResult_2 = _builder_15;
                  break;
                default:
                  _switchResult_2 = null;
                  break;
              }
            } else {
              _switchResult_2 = null;
            }
            _builder.append(_switchResult_2);
            _builder.append("\", \"start\": [");
            float _x = h.getCoordinates().getX();
            _builder.append(_x);
            _builder.append(", ");
            float _y = h.getCoordinates().getY();
            _builder.append(_y);
            _builder.append("], \"dest\": [");
            float _x_1 = p.getCoordinates().getX();
            _builder.append(_x_1);
            _builder.append(", ");
            float _y_1 = p.getCoordinates().getY();
            _builder.append(_y_1);
            _builder.append("], \"dext\": ");
            int _xifexpression = (int) 0;
            int _dext = h.getDext();
            boolean _equals_2 = (_dext == 0);
            if (_equals_2) {
              _xifexpression = (-1);
            } else {
              _xifexpression = h.getDext();
            }
            _builder.append(_xifexpression);
            _builder.append(", \"same_as\": -1, \"path\": -1 }");
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence pScenario(final Scenario scenario, final Mission mission, final ArrayList<Point2D.Float> intersections, final int max_n, final Parameter parameter) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\"queries\": [");
    _builder.append("\n\t\t", "\t");
    {
      EList<Query> _queries = mission.getQueries().getQueries();
      boolean _hasElements = false;
      for(final Query q : _queries) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",\n\t\t", "\t");
        }
        CharSequence _pQuery = this.pQuery(q);
        _builder.append(_pQuery, "\t");
      }
    }
    _builder.append("],");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"humans\": [");
    _builder.append("\n\t\t", "\t");
    int hid = 1;
    {
      EList<Human> _humans = scenario.getHumans().getHumans();
      boolean _hasElements_1 = false;
      for(final Human h : _humans) {
        if (!_hasElements_1) {
          _hasElements_1 = true;
        } else {
          _builder.appendImmediate(",\n\t\t", "\t");
        }
        int _plusPlus = hid++;
        final Function1<Assignment, Boolean> _function = (Assignment a) -> {
          return Boolean.valueOf(a.getClient().equals(h.getName()));
        };
        final Function1<Point, Boolean> _function_1 = (Point p) -> {
          final Function1<Assignment, Boolean> _function_2 = (Assignment a) -> {
            return Boolean.valueOf(a.getClient().equals(h.getName()));
          };
          return Boolean.valueOf(p.getName().equals(IterableExtensions.<Assignment>findFirst(mission.getAssignments(), _function_2).getTarget()));
        };
        CharSequence _pHumans = this.pHumans(_plusPlus, h, IterableExtensions.<Assignment>findFirst(mission.getAssignments(), _function), IterableExtensions.<Point>findFirst(scenario.getFloor().getPoints(), _function_1));
        _builder.append(_pHumans, "\t");
      }
    }
    _builder.append("],");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"robots\": [");
    _builder.append("\n\t\t", "\t");
    int rid = 1;
    {
      EList<Robot> _robots = scenario.getRobots().getRobots();
      boolean _hasElements_2 = false;
      for(final Robot r : _robots) {
        if (!_hasElements_2) {
          _hasElements_2 = true;
        } else {
          _builder.appendImmediate(",\n\t\t", "\t");
        }
        int _plusPlus_1 = rid++;
        CharSequence _pRobots = this.pRobots(_plusPlus_1, r, parameter);
        _builder.append(_pRobots, "\t");
      }
    }
    _builder.append("],");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"areas\": [");
    _builder.append("\n\t\t", "\t");
    {
      EList<Surface> _surfaces = scenario.getFloor().getSurfaces();
      boolean _hasElements_3 = false;
      for(final Surface s : _surfaces) {
        if (!_hasElements_3) {
          _hasElements_3 = true;
        } else {
          _builder.appendImmediate(",\n\t\t", "\t");
        }
        CharSequence _pAreas = this.pAreas(s);
        _builder.append(_pAreas, "\t");
      }
    }
    _builder.append("],");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"intersect\": [");
    _builder.append("\n\t\t", "\t");
    {
      boolean _hasElements_4 = false;
      for(final Point2D.Float i : intersections) {
        if (!_hasElements_4) {
          _hasElements_4 = true;
        } else {
          _builder.appendImmediate(",\n\t\t", "\t");
        }
        CharSequence _pIntersect = this.pIntersect(Double.valueOf(i.getX()).floatValue(), Double.valueOf(i.getY()).floatValue());
        _builder.append(_pIntersect, "\t");
      }
    }
    _builder.append("], ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("\"max_neigh\": ");
    _builder.append(max_n, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    return _builder;
  }
}
